/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/************************************ Includes ****************************************/


#include "CTRL_CAR.h"
#include "ALIG_CAR.h"
#include "CAR_PARK.h"
#include "FIND_PARKING.h"
#include "SELECT_US.h"
#include "SW_DELAY.h"

#include "std_types.h"
#include "bit_math.h"

#include "RCC_IF.h"
#include "GPIO_IF.h"
#include "US.h"

#define ENABLE_FIND_SLOT_PART         1

#define ENABLE_AFTER_SLOT_PART        1
#define ENABL_PARKING        1
#define FINAL_PARKING        1

#define BRAKE_DELAY_PARK	120
/**
 * 1 Sec  -- > 8000000
 * 4 Sec  -- > 32000000
 */
#define TIME_OUT_FOR_SLOT_SEARCH	32000000


#define FORCE_BREAK_FRM_FWD()  					C2VCONTROL_voidChangeDirection(VCLE_BWD,255	); \
												delay_ms(BRAKE_DELAY_PARK);\
												C2VCONTROL_voidChangeDirection(VCLE_STOP,0)



u8 arr[4][100] ;
u8 i , j , k , l ;
u8 iAvg , jAvg, kAvg, lAvg ;
u32 iSum , jSum, kSum , lsum ;
int main(void)
{
	APPC1_Init();
		RCC_voidInitSysClocks() ;		 		// Init Clock
		RCC_voidEnableClock(RCC_AHB, PORTA);		//PORTA
		RCC_voidEnableClock(RCC_AHB, PORTB);		//PORTB
		RCC_voidEnableClock(RCC_AHB, PORTC);		//PORTC
		RCC_voidEnableClock(RCC_APB1, Timer3);		//TIMER3

		US_ERROR_t LOC_eReturnState = US_INVALID_READING ;
		GPIO_voidSetPinDirection(PORTA,PIN0, GPIO_OUTPUT_LOW_SPD_PUSH_PULL);
		GPIO_voidSetPinDirection(PORTC,PIN2, GPIO_OUTPUT_LOW_SPD_PUSH_PULL);
		GPIO_voidSetPinDirection(PORTC,PIN3, GPIO_OUTPUT_LOW_SPD_PUSH_PULL);
		GPIO_voidSetPinDirection(PORTC,PIN0, GPIO_OUTPUT_LOW_SPD_PUSH_PULL);
	C2VCONTROL_voidInit();
	  u16 LOC_u8FrontDistance ,  LOC_u8BackDistance , LOC_u8FRDistance, LOC_u8BRDistance ;
	  ERROR_t LOC_xReturnError = E_OK ;
	  VCLE_State_t LOC_xVechileAlignState ;
	  u16 data = 0 ;
	  for(;;)
	{
//find slott
#if ENABLE_FIND_SLOT_PART == 1

		while(data == 0){
		  LOC_xReturnError=C4_StaticGetFourDistance(&LOC_u8FrontDistance,&LOC_u8BackDistance,&LOC_u8FRDistance,&LOC_u8BRDistance);
		//(void)LOC_eReturnState;

		  if(LOC_u8FRDistance >= MIN_DEPTH_TO_DETECT_SLOT && LOC_u8BRDistance >=MIN_DEPTH_TO_DETECT_SLOT)
		  {
			  C2VCONTROL_voidChangeDirection(VCLE_FWD,0);


			  data = 2 ;

		  }
		  else
		  {
		              // Still Searching  For Slot
		       C2VCONTROL_voidChangeDirection(VCLE_FWD,130);
		   }

		}

#endif

		 // C2VCONTROL_voidChangeDirection(VCLE_FWD,0);

	  //after find
/*		//خدت مساافه قداام سسيكاا تسهل الركنه
#if	  ENABLE_AFTER_SLOT_PART == 1
	  while (data ==1)
	 {

		 C2VCONTROL_voidChangeDirection(VCLE_FWD,131);

		 // LOC_xReturnError = C4_StaticGetFourDistance(&LOC_u8FrontDistance,&LOC_u8BackDistance,&LOC_u8FRDistance,&LOC_u8BRDistance);
	         // Measure Distance
	         LOC_xReturnError = C4_StaticGetFourDistance(&LOC_u8FrontDistance,&LOC_u8BackDistance,&LOC_u8FRDistance,&LOC_u8BRDistance);
	         if ((LOC_u8FRDistance <= 35 || LOC_u8BRDistance <= 35) )
	         {
	       	  C2VCONTROL_voidChangeDirection(VCLE_FWD,0);

	        	 data = 2 ;
	         }
	  }


#endif

*/



	  //start parkink
	  //alkasra faker wala ehhhhhh?
#if	  ENABL_PARKING == 1
		  C2VCONTROL_voidChangeDirection(VCLE_FWD,0);
		  u16 x=0;
if(data==2){

	while(x<=4){

		C2VCONTROL_voidChangeDirection( VCLE_RIGHT_FWD , 150);
		delay_ms(900);
		C2VCONTROL_voidChangeDirection(VCLE_FWD,0);
		C2VCONTROL_voidChangeDirection( VCLE_LEFT_BWD , 150);
		delay_ms(600);
		++x;
	}
	 C2VCONTROL_voidChangeDirection(VCLE_FWD,0);
	 /*LOC_u8BackDistance=10;
    while (LOC_u8BackDistance >=5 )
    {
    	C2VCONTROL_voidChangeDirection( VCLE_BWD , 135);
        LOC_xReturnError = C4_StaticGetFourDistance(&LOC_u8FrontDistance,&LOC_u8BackDistance,&LOC_u8FRDistance,&LOC_u8BRDistance);

    }
*/
 	C2VCONTROL_voidChangeDirection( VCLE_BWD , 135);
	delay_ms(2000);

	  C2VCONTROL_voidChangeDirection(VCLE_FWD,0);
  	data = 3;


}
#endif


#if	  FINAL_PARKING == 1

C2VCONTROL_voidChangeDirection(VCLE_FWD,0);
	 u16 y=0;
	 if(data==3){
	  while (y<4)
	   {
	     	C2VCONTROL_voidChangeDirection( VCLE_LEFT_FWD , 140);
	     	delay_ms(1200);

	     	C2VCONTROL_voidChangeDirection(VCLE_BWD,0);
	     	C2VCONTROL_voidChangeDirection( VCLE_RIGHT_BWD , 170);
	     	delay_ms(400);

	     	C2VCONTROL_voidChangeDirection(VCLE_BWD,0);

	        // LOC_xReturnError = C4_StaticGetFourDistance(&LOC_u8FrontDistance,&LOC_u8BackDistance,&LOC_u8FRDistance,&LOC_u8BRDistance);
	         ++y;
	   }
	  while (LOC_u8FrontDistance <=15 )
	     {
	     	C2VCONTROL_voidChangeDirection( VCLE_BWD , 135);
	         LOC_xReturnError = C4_StaticGetFourDistance(&LOC_u8FrontDistance,&LOC_u8BackDistance,&LOC_u8FRDistance,&LOC_u8BRDistance);

	     }
    	data = 4;
		  C2VCONTROL_voidChangeDirection(VCLE_FWD,0);
	 }
#endif


	 C2VCONTROL_voidChangeDirection(VCLE_FWD,0);

}
}
